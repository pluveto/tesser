---
title: Signal Lifecycle
description: What happens after your strategy fires a signal.
---

1. **Strategy emits `Signal`** – Typically from `on_tick` or `on_candle`. Use the provided `SignalBuilder` helpers to keep payloads consistent.
2. **Execution Engine** – Receives the signal, enriches it with portfolio context, and chooses an execution hint (VWAP, PeggedBest, Sniper, etc.).
3. **Risk Filters** – Guardrails (max position size, participation caps) run before any order hits the wire.
4. **Order Routing** – The engine translates the validated intent into `OrderRequest`s and hands them to the configured `ExecutionClient`.
5. **Fill Feedback** – Executions stream back through the event bus; the strategy can react in `on_fill`, and the portfolio updates realized PnL.

```text
Signal -> Execution -> Risk -> Orders -> Exchange -> Fills -> Portfolio
```

Keep the signal payload focused on *intent* (e.g., “go long BTCUSDT, size 0.5”). Pricing tactics, throttling, and compliance rules live downstream so they can be audited centrally.

## PeggedBest Execution Hint

Attach `ExecutionHint::PeggedBest` to a signal when you want the execution layer to rest passively at the top of book and automatically “chase” the quote. The orchestrator now keeps a single child order working on the exchange and issues native amendments instead of cancel/re-place cycles, which preserves queue position and dramatically reduces API weight consumption.

Tuning knobs:

- `offset_bps` – how far inside/outside the top of book the pegged order should anchor.
- `clip_size` – optional maximum displayed size per child (falls back to the full parent quantity).
- `refresh_secs` – minimum time between refreshes; use this with volatile markets to avoid thrashing.
- `min_chase_distance` – the newest knob; it sets the minimum price delta (in absolute quote terms) before a chase occurs, providing a guardrail against micro-ticks that would otherwise generate excessive amend calls.

Because the runtime amends the resting child order in place, fills stream back against a single order ID and state is persisted through restarts. Set `min_chase_distance` according to your tick size and exchange rate limits to balance spread capture against API pressure.

## TrailingStop Execution Hint

`ExecutionHint::TrailingStop` gives strategies a venue-agnostic trailing-stop primitive. Provide an `activation_price` and a fractional `callback_rate`. Once ticks trade through the activation level the orchestrator records the highest price seen, refreshing that watermark as the market rallies. If price ever falls below `highest * (1 - callback_rate)`, the algorithm fires a market sell that flattens the configured quantity.

This logic runs entirely inside the execution layer, so it inherits the same persistence/recovery guarantees as TWAP/VWAP. Use it to guard profits without wiring exchange-specific trailing orders or polluting strategy code with ticker state.
